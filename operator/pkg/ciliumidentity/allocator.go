// SPDX-License-Identifier: Apache-2.0
// Copyright Authors of Cilium

package ciliumidentity

import (
	"fmt"
	"strconv"
	"strings"

	"github.com/cilium/cilium/pkg/identity/key"
	"github.com/cilium/cilium/pkg/idpool"
	k8sConst "github.com/cilium/cilium/pkg/k8s/apis/cilium.io"
	"github.com/cilium/cilium/pkg/labels"
	"github.com/cilium/cilium/pkg/labelsfilter"
)

const (
	defaultMinIDValue       = 1 << 8  // 256
	defaultMaxIDValue       = 1 << 16 // 65536
	k8sPrefix               = labels.LabelSourceK8s + ":"
	k8sNamespaceLabelPrefix = labels.LabelSourceK8s + ":" + k8sConst.PodNamespaceMetaLabels + labels.PathDelimiter
)

// GlobalIDAllocator is only responsible for allocating global security
// identities (Cilium Identities) for Cilium Endpoints.
type GlobalIDAllocator struct {
	idPool     idpool.IDPool
	minIDValue idpool.ID
	maxIDValue idpool.ID
}

// NewGlobalIDAllocator creates a new GlobalIDAllocator for ID values between
// the provided minIDValue and maxIDValue.
func NewGlobalIDAllocator(minIDValue, maxIDValue idpool.ID) *GlobalIDAllocator {
	return &GlobalIDAllocator{
		idPool:     idpool.NewIDPool(minIDValue, maxIDValue),
		minIDValue: minIDValue,
		maxIDValue: maxIDValue,
	}
}

func (g *GlobalIDAllocator) AllocateRandom() (idpool.ID, error) {
	id := g.idPool.AllocateID()
	if id == idpool.NoID {
		return id, fmt.Errorf("failed to allocate random global security ID")
	}

	return id, nil
}

func (g *GlobalIDAllocator) Allocate(id idpool.ID) error {
	if !g.IsGlobalID(id) {
		return fmt.Errorf("cannot allocate %d because it's out of the pool range [%d, %d]", id, g.minIDValue, g.maxIDValue)
	}

	idRemovedFromPool := g.idPool.Remove(id)
	if !idRemovedFromPool {
		return fmt.Errorf("failed to allocate global security ID=%d", id)
	}

	return nil
}

func (g *GlobalIDAllocator) ReturnToAvailablePool(id idpool.ID) error {
	if !g.IsGlobalID(id) {
		return fmt.Errorf("cannot return %d to the available pool because it's out of the pool range [%d, %d]", id, g.minIDValue, g.maxIDValue)
	}

	idReleased := g.idPool.Insert(id)
	if !idReleased {
		return fmt.Errorf("failed to return global security ID %d to available pool", id)
	}

	return nil
}

func (g *GlobalIDAllocator) IsGlobalID(id idpool.ID) bool {
	return id >= g.minIDValue && id <= g.maxIDValue
}

func (g *GlobalIDAllocator) ValidateCIDName(cidName string) (int64, error) {
	idInt, err := strconv.Atoi(cidName)
	if err != nil {
		return 0, fmt.Errorf("failed to validate id(%d): %v", idInt, err)
	}

	if idInt < 0 {
		return 0, fmt.Errorf("failed to validate id(%d), id cannot be negative", idInt)
	}

	idInt64 := int64(idInt)

	if !g.IsGlobalID(idpool.ID(idInt64)) {
		return 0, fmt.Errorf("failed to validate id(%d), out of the allocated bounds [%d, %d]", idInt, g.minIDValue, g.maxIDValue)
	}

	return idInt64, nil
}

func GetCIDKeyFromK8sLabels(k8sLabels map[string]string) *key.GlobalIdentity {
	lbls := labels.Map2Labels(k8sLabels, labels.LabelSourceK8s)
	idLabels, _ := labelsfilter.Filter(lbls)
	return &key.GlobalIdentity{LabelArray: idLabels.LabelArray()}
}

func GetCIDKeyFromSecurityLabels(secLabels map[string]string) *key.GlobalIdentity {
	lbls := labels.Map2Labels(secLabels, "")
	idLabels, _ := labelsfilter.Filter(lbls)
	return &key.GlobalIdentity{LabelArray: idLabels.LabelArray()}
}

func SecurityLabelsAreEqual(secLabelsA, secLabelsB map[string]string) bool {
	lblsA := labels.Map2Labels(secLabelsA, "")
	idLabelsA, _ := labelsfilter.Filter(lblsA)
	lblsB := labels.Map2Labels(secLabelsB, "")
	idLabelsB, _ := labelsfilter.Filter(lblsB)
	return idLabelsA.Equals(idLabelsB)
}

// SanitizeK8sLabels strips the 'k8s:' prefix in the labels generated by
// AllocatorKey.GetAsMap (when the key is k8s labels). In the CRD identity case
// we map the labels directly to the ciliumidentity CRD instance, and
// kubernetes does not allow ':' in the name of the label. These labels are not
// the canonical labels of the identity, but used to ease interaction with the
// CRD object.
func SanitizeK8sLabels(old map[string]string) (selected, skipped map[string]string) {
	skipped = make(map[string]string, len(old))
	selected = make(map[string]string, len(old))
	for k, v := range old {
		// Skip non-k8s labels.
		// Skip synthesized labels for k8s namespace labels, since they contain user input which can result in the label
		// name being longer than 63 characters.
		if !strings.HasPrefix(k, k8sPrefix) || strings.HasPrefix(k, k8sNamespaceLabelPrefix) {
			skipped[k] = v
			continue // skip non-k8s labels
		}
		k = strings.TrimPrefix(k, k8sPrefix) // k8s: is redundant
		selected[k] = v
	}
	return selected, skipped
}
